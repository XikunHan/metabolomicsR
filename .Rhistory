df
df
df@assayData[, 1]
df@sampleData
df <- rbind(df@assayData[, 1], batch = df@sampleData[,7], df@assayData[, -1])
df@assayData[, -1]
df <- cbind(df@assayData[, 1], batch = df@sampleData[,7], df@assayData[, -1])
df
df <- df_urine_QC
df <- cbind(df@assayData[, 1], df@sampleData[,7], df@assayData[, -1])
df
setnames(df, 2, "batch")
df
object <- df
object <- filter_column_constant(object, verbose = verbose)
filter_column_constant = TRUE
filter_column_missing_rate_threshold = 0.5
filter_row_missing_rate_threshold = NULL
replace_outlier_method = NULL
nSD = 5
impute_method = "half-min"
verbose = TRUE
logs <- paste0(logs, "\n",
format(Sys.time(), "%d/%m/%y %H:%M:%OS"),
": Run QC pipeline.\n")
logs <- paste0("Logs: ", "\n",
format(Sys.time(), "%d/%m/%y %H:%M:%OS"),
": Run QC pipeline.\n")
logs
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
View(object)
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
View(object)
plot( df[,5], object[, 4])
df[,5]
object[, 4]
plot( df[,5], object[, 4])
plot( df[,5], object[, 4])
plot( df$M38002, object$M38002)
plot( df$M20675, object$M20675)
df <- copy(df_urine_QC)
df <- cbind(df@assayData[, 1], df@sampleData[,7], df@assayData[, -1])
df
setnames(df, 2, "batch")
filter_column_constant = TRUE
filter_column_missing_rate_threshold = 0.5
filter_row_missing_rate_threshold = NULL
replace_outlier_method = NULL
nSD = 5
impute_method = "half-min"
verbose = TRUE
object <- copy(df)
plot( df$M38002, object$M38002)
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
plot( df$M38002, object$M38002)
plot( df$M20675, object$M20675)
outlier_rate(df)
hist(outlier_rate(df))
plot( df$M32391, object$M32391)
object$M32391
df$M32391
hist(outlier_rate(df))
max(outlier_rate(df))
max(outlier_rate(df), na.rm = T)
sort(outlier_rate(df), decreasing = T)
plot( df$M36589, object$M36589)
object <- copy(df)
plot( df$M38002, object$M38002)
plot( df$M36589, object$M36589)
logs <- paste0("Logs: ", "\n",
format(Sys.time(), "%d/%m/%y %H:%M:%OS"),
": Run QC pipeline.\n")
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
replace_outlier_method
hist(outlier_rate(df))
plot( df$M38002, object$M38002)
plot( df$M36589, object$M36589)
replace_outlier_method = "winsorize"
if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
plot( df$M38002, object$M38002)
df
object
object <- object[, -c(1,2)]
logs <- paste0("Logs: ", "\n",
format(Sys.time(), "%d/%m/%y %H:%M:%OS"),
": Run QC pipeline.\n")
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
object <- copy(df)
object <- object[, -c(1,2)]
object
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
object
object <- copy(df)
object <- object[, -c(1,2)]
object
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
object
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
object
object2 <- apply(object, 2, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
object2 <- lapply(object, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
object2 <- apply(object,2, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
#' @rdname replace_outlier
#' @export
replace_outlier.data.frame <- function(object, method = "winsorize", nSD = 5) {
object <- apply(object, 2, replace_outlier, method = method, nSD = nSD)
object <- data.table(object)
return(object)
}
object2 <- apply(object,2, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
object <- data.table(obe)
object <- data.table(object)
object <- apply(object,2, replace_outlier, method = "winsorize", nSD = 5)
str(object)
object <- data.table(object)
if(!is.null(impute_method)) {
object <- impute(object, method = impute_method)
}
impute_method
#' @rdname impute
#' @export
impute.data.frame <- function(object, method = c('half-min', "median", "mean", "zero", "kNN")) {
method <- match.arg(method)
if(method == "kNN") {
return(impute_kNN(object))
}
object <- apply(object, 2, impute, method = method)
object <- data.table(object)
return(object)
}
if(!is.null(impute_method)) {
object <- impute(object, method = impute_method)
}
object
View(object)
plot( df$M38002, object$M38002)
plot( df$M36589, object$M36589)
#' batch normalization for a data.frame
#'
#' Normalization data by the median value of each batch in a data.frame
#'
#' @param object A data.frame object. The first two columns are "ID" and "Batch", the remaining columns for batch normalization
#' @param test test the function for the first 20 columns.
#' @param verbose print log information.
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @return A data.frame object after normalization.
#' @export
batch_norm_df <- function(object, test = FALSE, verbose = TRUE) {
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
v_n_col
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
v_batch <- unlist(platforms)
for(j in 3L:v_n_col) {
setTxtProgressBar(pb = pb, value = j)
v_metab <- names(object)[j]
InputData_each <- unlist(InputData[, j, with = FALSE])
for (id_batch in unique(v_batch[! is.na(v_batch)])) {
Index_each <- (v_batch  == id_batch)
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
set(OutputData, which(Index_each), j, InputData_each[which(Index_each)]/v_median)
}
}
close(con = pb)
return(object)
}
object
View(object)
View(df)
object2 <- batch_norm_df(cbind(df[,1:2], object))
cbind(df[,1:2], object
)
object2 <- batch_norm_df(ID = df$sampleID, Batch = df$batch, object))
object2 <- batch_norm_df(cbind(ID = df$sampleID, Batch = df$batch, object))
View(object2)
plot( object2$M36589, object$M36589)
plot( object2$M38002, object$M38002)
View(object2)
View(object)
#' batch normalization for a data.frame
#'
#' Normalization data by the median value of each batch in a data.frame
#'
#' @param object A data.frame object. The first two columns are "ID" and "Batch", the remaining columns for batch normalization
#' @param test test the function for the first 20 columns.
#' @param verbose print log information.
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @return A data.frame object after normalization.
#' @export
batch_norm_df <- function(object, test = FALSE, verbose = TRUE) {
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
v_n_col
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
v_batch <- unlist(platforms)
for(j in 3L:v_n_col) {
setTxtProgressBar(pb = pb, value = j)
v_metab <- names(object)[j]
InputData_each <- unlist(InputData[, j, with = FALSE])
for (id_batch in unique(v_batch[! is.na(v_batch)])) {
Index_each <- (v_batch  == id_batch)
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
set(OutputData, which(Index_each), j, InputData_each[which(Index_each)]/v_median)
}
}
close(con = pb)
return(object)
}
object2 <- batch_norm_df(cbind(ID = df$sampleID, Batch = df$batch, object))
plot( object2$M36589, object$M36589)
plot( object2$M38002, object$M38002)
new <- cbind(ID = df$sampleID, Batch = df$batch, object)
str(new)
object2 <- batch_norm_df(new)
plot( object2$M36589, new$M36589)
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
object <- new
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
platforms
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
v_n_col
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
sample_IDs
v_batch <- unlist(platforms)
v_batch
j <- 3L
v_metab <- names(object)[j]
v_metab
InputData_each <- unlist(InputData[, j, with = FALSE])
InputData_each
unique(v_batch[! is.na(v_batch)])
id_batch <- 1
Index_each <- (v_batch  == id_batch)
Index_each
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
v_median
#' batch normalization for a data.frame
#'
#' Normalization data by the median value of each batch in a data.frame
#'
#' @param object A data.frame object. The first two columns are "ID" and "Batch", the remaining columns for batch normalization
#' @param test test the function for the first 20 columns.
#' @param verbose print log information.
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @return A data.frame object after normalization.
#' @export
batch_norm_df <- function(object, test = FALSE, verbose = TRUE) {
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
v_batch <- platforms
for(j in 3L:v_n_col) {
setTxtProgressBar(pb = pb, value = j)
v_metab <- names(object)[j]
InputData_each <- unlist(InputData[, j, with = FALSE])
for (id_batch in unique(v_batch[! is.na(v_batch)])) {
Index_each <- (v_batch  == id_batch)
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
set(OutputData, which(Index_each), j, InputData_each[which(Index_each)]/v_median)
}
}
close(con = pb)
return(OutputData)
}
object2 <- batch_norm_df(new)
plot( object2$M36589, new$M36589)
plot( object2$M38002, object$M38002)
remove.packages("metabolomicsR")
rs.restartR()
q()
remove.packages("metabolomicsR")
rs.restartR()
devtools::document()
devtools::document()
rs.restartR()
devtools::document()
devtools::document()
remove.packages("metabolomicsR")
rs.restartR()
devtools::document()
devtools::install()
devtools::check()
# BiocManager::install("BiocStyle")
BiocManager::install("BiocStyle")
devtools::check()
install.packages("hrbrthemes")
devtools::check()
install.packages("ggstatsplot")
install.packages("ggstatsplot")
library(data.table)
library(ggplot2)
library(cowplot)
library(plotROC)
library(maplet)
install.packages("maplet")
devtools::install_github(repo="krumsieklab/maplet", subdir="maplet")
install.packages("ggmosaic")
devtools::install_github(repo="krumsieklab/maplet", subdir="maplet")
install.packages("network")
devtools::install_github(repo="krumsieklab/maplet", subdir="maplet")
install.packages("pathview")
devtools::install_github(repo="krumsieklab/maplet@v1.2.1", subdir="maplet")
devtools::check()
install.packages("magick")
devtools::check()
install.packages("M3C")
BiocManager::install("M3C")
library(M3C)
devtools::check(vignettes = FALSE) # fast
install.packages("ggthemes", "impute")
install.packages(c("ggthemes", "impute"))
BiocManager::install( "hmdbQuery")
BiocManager::install("impute")
BiocManager::install("impute")
devtools::check(vignettes = FALSE) # fast
devtools::check(vignettes = FALSE) # fast
library(devtools)
library(genuMet)
install_github("xyomics/genuMet")
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
install.packages("callr")
install.packages("callr")
devtools::check(vignettes = FALSE) # fast, run first
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
pkgdown::build_site() # for pkgdown doc
q()
remove.packages("metabolomicsR")
remove.packages("metabolomicsR")
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
.Last.error
install.packages("pkgdown")
install.packages("pkgdown")
usethis::use_pkgdown()
devtools::document()
devtools::install()
devtools::check(vignettes = FALSE) # fast, run first
pkgdown::build_site() # for pkgdown doc
devtools::check()
pkgdown::build_site() # for pkgdown doc
devtools::document()
devtools::install()
remove.packages("metabolomicsR")
devtools::document()
devtools::install()
q()
remove.packages("metabolomicsR")
rs.restartR()
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
devtools::spell_check()
devtools::release()
devtools::check()
#
df <- fread("~/Downloads/lipid.csv")
#
lipid <- fread("~/Downloads/lipid.csv")
library(metabolomicsR)
lipid_input <- lipid[, c(1, 6, 7:405)]
names(lipid_input)[1:2] <- c("ID", "Batch")
data <- QC_pipeline_df(lipid_input, replace_outlier_method = "winsorize", run_batch_norm = T)
plot(data$AcCa_10_0_H, lipid$AcCa_10_0_H)
boxplot(lipid$AcCa_10_0_H ~ lipid$lab_batch)
boxplot(data$AcCa_10_0_H ~ data$lab_batch)
boxplot(data$AcCa_10_0_H ~ data$Batch)
q()
