if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
plot( df$M38002, object$M38002)
df
object
object <- object[, -c(1,2)]
logs <- paste0("Logs: ", "\n",
format(Sys.time(), "%d/%m/%y %H:%M:%OS"),
": Run QC pipeline.\n")
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
object <- copy(df)
object <- object[, -c(1,2)]
object
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
if(!is.null(replace_outlier_method)) {
object <- replace_outlier(object, method = replace_outlier_method, nSD = nSD)
}
object
object <- copy(df)
object <- object[, -c(1,2)]
object
if(filter_column_constant) {
object <- filter_column_constant(object, verbose = verbose)
}
object
if(!is.null(filter_column_missing_rate_threshold)) {
object <- filter_column_missing_rate(object, threshold = filter_column_missing_rate_threshold, verbose = verbose)
}
object
if(!is.null(filter_row_missing_rate_threshold)) {
object <- filter_row_missing_rate(object, threshold = filter_row_missing_rate_threshold, verbose = verbose)
}
object
object2 <- apply(object, 2, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
object2 <- lapply(object, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
object2 <- apply(object,2, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
#' @rdname replace_outlier
#' @export
replace_outlier.data.frame <- function(object, method = "winsorize", nSD = 5) {
object <- apply(object, 2, replace_outlier, method = method, nSD = nSD)
object <- data.table(object)
return(object)
}
object2 <- apply(object,2, replace_outlier, method = "winsorize", nSD = 5)
str(object2)
object <- data.table(obe)
object <- data.table(object)
object <- apply(object,2, replace_outlier, method = "winsorize", nSD = 5)
str(object)
object <- data.table(object)
if(!is.null(impute_method)) {
object <- impute(object, method = impute_method)
}
impute_method
#' @rdname impute
#' @export
impute.data.frame <- function(object, method = c('half-min', "median", "mean", "zero", "kNN")) {
method <- match.arg(method)
if(method == "kNN") {
return(impute_kNN(object))
}
object <- apply(object, 2, impute, method = method)
object <- data.table(object)
return(object)
}
if(!is.null(impute_method)) {
object <- impute(object, method = impute_method)
}
object
View(object)
plot( df$M38002, object$M38002)
plot( df$M36589, object$M36589)
#' batch normalization for a data.frame
#'
#' Normalization data by the median value of each batch in a data.frame
#'
#' @param object A data.frame object. The first two columns are "ID" and "Batch", the remaining columns for batch normalization
#' @param test test the function for the first 20 columns.
#' @param verbose print log information.
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @return A data.frame object after normalization.
#' @export
batch_norm_df <- function(object, test = FALSE, verbose = TRUE) {
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
v_n_col
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
v_batch <- unlist(platforms)
for(j in 3L:v_n_col) {
setTxtProgressBar(pb = pb, value = j)
v_metab <- names(object)[j]
InputData_each <- unlist(InputData[, j, with = FALSE])
for (id_batch in unique(v_batch[! is.na(v_batch)])) {
Index_each <- (v_batch  == id_batch)
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
set(OutputData, which(Index_each), j, InputData_each[which(Index_each)]/v_median)
}
}
close(con = pb)
return(object)
}
object
View(object)
View(df)
object2 <- batch_norm_df(cbind(df[,1:2], object))
cbind(df[,1:2], object
)
object2 <- batch_norm_df(ID = df$sampleID, Batch = df$batch, object))
object2 <- batch_norm_df(cbind(ID = df$sampleID, Batch = df$batch, object))
View(object2)
plot( object2$M36589, object$M36589)
plot( object2$M38002, object$M38002)
View(object2)
View(object)
#' batch normalization for a data.frame
#'
#' Normalization data by the median value of each batch in a data.frame
#'
#' @param object A data.frame object. The first two columns are "ID" and "Batch", the remaining columns for batch normalization
#' @param test test the function for the first 20 columns.
#' @param verbose print log information.
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @return A data.frame object after normalization.
#' @export
batch_norm_df <- function(object, test = FALSE, verbose = TRUE) {
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
v_n_col
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
v_batch <- unlist(platforms)
for(j in 3L:v_n_col) {
setTxtProgressBar(pb = pb, value = j)
v_metab <- names(object)[j]
InputData_each <- unlist(InputData[, j, with = FALSE])
for (id_batch in unique(v_batch[! is.na(v_batch)])) {
Index_each <- (v_batch  == id_batch)
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
set(OutputData, which(Index_each), j, InputData_each[which(Index_each)]/v_median)
}
}
close(con = pb)
return(object)
}
object2 <- batch_norm_df(cbind(ID = df$sampleID, Batch = df$batch, object))
plot( object2$M36589, object$M36589)
plot( object2$M38002, object$M38002)
new <- cbind(ID = df$sampleID, Batch = df$batch, object)
str(new)
object2 <- batch_norm_df(new)
plot( object2$M36589, new$M36589)
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
object <- new
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
platforms
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
v_n_col
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
sample_IDs
v_batch <- unlist(platforms)
v_batch
j <- 3L
v_metab <- names(object)[j]
v_metab
InputData_each <- unlist(InputData[, j, with = FALSE])
InputData_each
unique(v_batch[! is.na(v_batch)])
id_batch <- 1
Index_each <- (v_batch  == id_batch)
Index_each
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
v_median
#' batch normalization for a data.frame
#'
#' Normalization data by the median value of each batch in a data.frame
#'
#' @param object A data.frame object. The first two columns are "ID" and "Batch", the remaining columns for batch normalization
#' @param test test the function for the first 20 columns.
#' @param verbose print log information.
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @return A data.frame object after normalization.
#' @export
batch_norm_df <- function(object, test = FALSE, verbose = TRUE) {
stopifnot(inherits(object, "data.frame"))
OutputData <- copy(object)
InputData <- copy(object)
# check first two column
if(! all(names(object)[1:2] %in% c("ID", "Batch")) ) {
stop(paste0("`", names(object)[1:2], "` columns should be ID and Batch"), call. = FALSE)
}
platforms <- object[, get("Batch")]
if(verbose) {
cat("\nBatch information:\n")
print(table(platforms))
cat("\n")
}
v_n_col <- dim(object)[2]
if(isTRUE(test)) {
v_n_col <- 10
} else if(test >=2 ) {
v_n_col <- test
}
pb <- txtProgressBar(min = 0, max = v_n_col, style = 3, file = stderr())
sample_IDs <- object[,get("ID")]
v_batch <- platforms
for(j in 3L:v_n_col) {
setTxtProgressBar(pb = pb, value = j)
v_metab <- names(object)[j]
InputData_each <- unlist(InputData[, j, with = FALSE])
for (id_batch in unique(v_batch[! is.na(v_batch)])) {
Index_each <- (v_batch  == id_batch)
v_median <- median(InputData_each[Index_each], na.rm = TRUE)
set(OutputData, which(Index_each), j, InputData_each[which(Index_each)]/v_median)
}
}
close(con = pb)
return(OutputData)
}
object2 <- batch_norm_df(new)
plot( object2$M36589, new$M36589)
plot( object2$M38002, object$M38002)
remove.packages("metabolomicsR")
rs.restartR()
q()
remove.packages("metabolomicsR")
rs.restartR()
devtools::document()
devtools::document()
rs.restartR()
devtools::document()
devtools::document()
remove.packages("metabolomicsR")
rs.restartR()
devtools::document()
devtools::install()
devtools::check()
# BiocManager::install("BiocStyle")
BiocManager::install("BiocStyle")
devtools::check()
install.packages("hrbrthemes")
devtools::check()
install.packages("ggstatsplot")
install.packages("ggstatsplot")
library(data.table)
library(ggplot2)
library(cowplot)
library(plotROC)
library(maplet)
install.packages("maplet")
devtools::install_github(repo="krumsieklab/maplet", subdir="maplet")
install.packages("ggmosaic")
devtools::install_github(repo="krumsieklab/maplet", subdir="maplet")
install.packages("network")
devtools::install_github(repo="krumsieklab/maplet", subdir="maplet")
install.packages("pathview")
devtools::install_github(repo="krumsieklab/maplet@v1.2.1", subdir="maplet")
devtools::check()
install.packages("magick")
devtools::check()
install.packages("M3C")
BiocManager::install("M3C")
library(M3C)
devtools::check(vignettes = FALSE) # fast
install.packages("ggthemes", "impute")
install.packages(c("ggthemes", "impute"))
BiocManager::install( "hmdbQuery")
BiocManager::install("impute")
BiocManager::install("impute")
devtools::check(vignettes = FALSE) # fast
devtools::check(vignettes = FALSE) # fast
library(devtools)
library(genuMet)
install_github("xyomics/genuMet")
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
install.packages("callr")
install.packages("callr")
devtools::check(vignettes = FALSE) # fast, run first
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
pkgdown::build_site() # for pkgdown doc
q()
remove.packages("metabolomicsR")
remove.packages("metabolomicsR")
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
.Last.error
install.packages("pkgdown")
install.packages("pkgdown")
usethis::use_pkgdown()
devtools::document()
devtools::install()
devtools::check(vignettes = FALSE) # fast, run first
pkgdown::build_site() # for pkgdown doc
devtools::check()
pkgdown::build_site() # for pkgdown doc
devtools::document()
devtools::install()
remove.packages("metabolomicsR")
devtools::document()
devtools::install()
q()
remove.packages("metabolomicsR")
rs.restartR()
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
devtools::spell_check()
devtools::release()
devtools::check()
#
df <- fread("~/Downloads/lipid.csv")
#
lipid <- fread("~/Downloads/lipid.csv")
library(metabolomicsR)
lipid_input <- lipid[, c(1, 6, 7:405)]
names(lipid_input)[1:2] <- c("ID", "Batch")
data <- QC_pipeline_df(lipid_input, replace_outlier_method = "winsorize", run_batch_norm = T)
plot(data$AcCa_10_0_H, lipid$AcCa_10_0_H)
boxplot(lipid$AcCa_10_0_H ~ lipid$lab_batch)
boxplot(data$AcCa_10_0_H ~ data$lab_batch)
boxplot(data$AcCa_10_0_H ~ data$Batch)
q()
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
devtools::document()
devtools::install()
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
q()
remove.packages("metabolomicsR")
devtools::document()
devtools::install()
pkgdown::build_site() # for pkgdown doc
devtools::check()
library(BiocStyle)
library(metabolomicsR)
library(data.table)
library(ggplot2)
library(cowplot)
library(plotROC)
file_path <- base::system.file("extdata", "QMDiab_metabolomics_OrigScale.xlsx", package = "metabolomicsR", mustWork = TRUE)
df_plasma <- load_excel(path = file_path,
data_sheet = 1,
feature_sheet = 4,
sample_sheet = 8,
sampleID = "QMDiab-ID",
featureID = "BIOCHEMICAL"
)
devtools::document()
devtools::install()
file_path <- base::system.file("extdata", "QMDiab_metabolomics_OrigScale.xlsx", package = "metabolomicsR", mustWork = TRUE)
df_plasma <- load_excel(path = file_path,
data_sheet = 1,
feature_sheet = 4,
sample_sheet = 8,
sampleID = "QMDiab-ID",
featureID = "BIOCHEMICAL"
)
# change the feature ID to the column `COMP_IDstr`
df_plasma <- update_Metabolite(df_plasma, dataset = "COMP_IDstr", action = "change_featureID")
# load urine metabolomic data
df_urine <- load_excel(path = file_path,
data_sheet = 2,
feature_sheet = 5,
sample_sheet = 9,
sampleID = "QMDiab-ID",
featureID = "BIOCHEMICAL"
)
df_urine <- update_Metabolite(df_urine, dataset = "COMP_IDstr", action = "change_featureID")
# load saliva metatabolomic data
df_saliva <- load_excel(path = file_path,
data_sheet = 3,
feature_sheet = 6,
sample_sheet = 10,
sampleID = "QMDiab-ID",
featureID = "BIOCHEMICAL"
)
df_saliva <- update_Metabolite(df_saliva, dataset = "COMP_IDstr", action = "change_featureID")
p <- plot_QC(df_plasma)
p$p
df_plasma_QC <- QC_pipeline(df_plasma, replace_outlier_method = "winsorize", impute_method = NULL)
p <- plot_QC(df_urine)
p$p
df_urine_QC
p <- plot_QC(df_saliva)
p$p
df_saliva_QC <- QC_pipeline(df_saliva, replace_outlier_method = "winsorize", impute_method = NULL)
df_saliva_QC
df_plasma_QC <- impute(df_plasma_QC, method = "half-min")
df_plasma_scale <-  transformation(df_plasma_QC, method = "log")
df_plasma_scale <-  transformation(df_plasma_scale, method = "scale")
# if no features were selected, randomly show 16 metabolites
plot_Metabolite(df_plasma_QC, plot = "boxplot", x = "T2D", color ="ETHNICITY", shape = "T2D")
# select three metabolites
plot_Metabolite(df_plasma_QC, x = "T2D", plot = "boxplot", feature_name = c("M43027",  "M11953", "M38002"))
# comparisons between groups using `ggbetweenstats`
plot_Metabolite(df_plasma_QC, x = "T2D", plot = "betweenstats",  feature_name = c("M43027",  "M11953"))
plot_Metabolite(df_plasma_scale, plot = "boxplot", x = "T2D", color ="ETHNICITY", shape = "T2D")
plot_Metabolite(df_plasma_scale, plot = "histogram", color = "T2D")
plot_Metabolite(df_plasma_scale, plot = "histogram", color = "ETHNICITY")
# Take the urine data for example, the batch of the samples are missing. To illustrate the usage of the normalization method, we assume that 120 samples in each batch.
unique(featureData(df_urine_QC)$PLATFORM)
# add new columns by reference (column name uppercase)
sampleData(df_urine_QC)[, `GC/MS` := rep(1:3, each = 120)[1:359]]
fit_lm <- regression(object = df_plasma_scale, phenoData = NULL,
model = "lm", outcome = "BMI",
covars = c("AGE", "GENDER", "ETHNICITY"),
factors = "ETHNICITY")
head(fit_lm)
dd <- merge(fit_lm, featureData(df_plasma_scale), by.x = "term", by.y = "featureID")
dd[, sig := ifelse(p.value.adj < 0.1, 1, 0)]
plot_volcano(dd, color = NULL, label = "BIOCHEMICAL")
df_sig <- dd[sig == 1 & !is.na(HMDb_ID), ]
df_sig
library(stringr)
# this function is used to change HMDB ID.
add_two_zeros <- function(x) {
if(str_count(x) == 9) x <- str_replace(x, "HMDB", "HMDB00")
return(x)
}
v_list <- sapply(df_sig$HMDb_ID, add_two_zeros)
v_list
df_sig$HMDB_anno <- anno_hmdb(v_list)
df_sig
# explore the first entry
df_sig$HMDB_anno[[1]]@metabolite
df_sig$HMDB_anno[[1]]@diseases
q()
